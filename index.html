<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agency Health Snapshot — Enhanced</title>
  <style>
    /* ====== Base + Theme Styles ====== */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #222;
      --dial-bg: #fff;
      --border-color: #ddd;
      --badge-color: #666;
    }
    [data-theme="dark"] {
      --bg-color: #1e1e1e;
      --text-color: #eee;
      --dial-bg: #2b2b2b;
      --border_color: #444;
      --badge-color: #ccc;
    }
    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    #snapshot-container {
      max-width: 900px;
      margin: 0 auto;
    }
    #theme-toggle {
      position: fixed;
      top: 16px;
      right: 16px;
      cursor: pointer;
      padding: 6px 12px;
      border: 1px solid var(--border_color);
      border-radius: 4px;
      background: var(--dial-bg);
      color: var(--text-color);
    }
    #dials {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .dial {
      background: var(--dial-bg);
      border: 1px solid var(--border_color);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
      transition: background 0.3s;
    }
    .dial .value {
      font-size: 2.2em;
      display: block;
      margin-top: 8px;
    }
    .dial .badge {
      display: block;
      margin-top: 6px;
      color: var(--badge-color);
      font-size: 0.9em;
    }
    #upload-section {
      margin-top: 20px;
    }
    input[type="file"] {
      margin: 10px 0;
    }
    .error {
      color: #c00;
      margin-top: 10px;
    }
  </style>
</head>
<body data-theme="light">
  <button id="theme-toggle">Toggle Theme</button>
  <div id="snapshot-container">
    <h1>Agency Health Snapshot — Enhanced</h1>

    <div id="dials">
      <div class="dial" id="benchscore-dial">
        <h2>BenchScore™</h2>
        <span class="value" id="benchscore-value">—</span>
        <span class="badge" id="benchscore-badge">?</span>
      </div>
      <div class="dial" id="timeback-dial">
        <h2>Time‑Back Number</h2>
        <span class="value" id="timeback-value">—</span>
        <span class="badge" id="timeback-badge">?</span>
      </div>
      <div class="dial" id="remarketload-dial">
        <h2>Remarketing Load</h2>
        <span class="value" id="remarketload-value">—</span>
        <span class="badge" id="remarketload-badge">?</span>
      </div>
      <div class="dial" id="sti-dial">
        <h2>Service Touch Index</h2>
        <span class="value" id="sti-value">—</span>
        <span class="badge" id="sti-badge">?</span>
      </div>
      <div class="dial" id="depth-dial">
        <h2>Coverage Depth</h2>
        <span class="value" id="depth-value">—</span>
        <span class="badge" id="depth-badge">?</span>
      </div>
      <div class="dial" id="tenure-dial">
        <h2>Tenure Momentum</h2>
        <span class="value" id="tenure-value">—</span>
        <span class="badge" id="tenure-badge">?</span>
      </div>
    </div>

    <div id="upload-section">
      <h3>Upload Household Snapshot CSV</h3>
      <input type="file" id="household-csv-input" accept=".csv" />
      <h3>Upload Event Log CSV (optional)</h3>
      <input type="file" id="event-csv-input" accept=".csv" />
      <div class="error" id="upload-error"></div>
    </div>
  </div>

  <script type="module">
    /***** CSV Parsing (basic, supports quoted) *****/
    function parseCSV(text) {
      const rows = [];
      const reLine = /\\r?\\n/;
      const lines = text.split(reLine).filter(l => l.trim() !== '');
      if (!lines.length) return [];
      const header = lines[0].match(/(".*?"|[^",\\s]+)(?=,|$)/g).map(h => h.replace(/^"|"$/g, ''));
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].match(/(".*?"|[^",\\s]+)(?=,|$)/g) || [];
        const obj = {};
        header.forEach((h, idx) => {
          let v = cols[idx] || '';
          v = v.replace(/^"|"$/g, '');
          obj[h.trim()] = v.trim();
        });
        rows.push(obj);
      }
      return rows;
    }

    /***** Input Parsing *****/
    function parseHouseholdRow(row) {
      return {
        householdId: row['household_id'] || null,
        tenureYears: parseFloat(row['tenure_years']) || 0,
        linesCount: parseInt(row['lines_count']) || 0,
        bundled: row['bundled_flag'] === '1' || row['bundled_flag'] === 'true',
        umbrella: row['umbrella_flag'] === '1' || row['umbrella_flag'] === 'true',
        renewalDate: row['renewal_date'] ? new Date(row['renewal_date']) : null,
        writtenPremium: parseFloat(row['written_premium_total']) || 0,
        commissionPct: parseFloat(row['commission_rate_pct']) || 0,
        serviceTouches12m: parseInt(row['service_touches_12m']) || 0,
        avgMinutesPerTouch: parseFloat(row['avg_minutes_per_touch']) || 0,
        remarkets12m: parseInt(row['remarkets_12m']) || 0,
        estMinPerRemarket: parseFloat(row['est_minutes_per_remarket']) || 0,
        endorsements: {
          waterBackupLimit: parseFloat(row['water_backup_limit']) || 0,
          serviceLineCoverage: parseFloat(row['service_line_coverage_limit']) || 0,
          equipmentBreakdown: row['equipment_breakdown_flag'] === '1' || row['equipment_breakdown_flag'] === 'true',
          // … add more endorsements as needed
        },
        discounts: {
          bundleDiscount: row['bundle_discount_flag'] === '1' || row['bundle_discount_flag'] === 'true',
          eft: row['eft'] === '1' || row['eft'] === 'true',
          payInFull: row['pay_in_full'] === '1' || row['pay_in_full'] === 'true',
          paperless: row['paperless'] === '1' || row['paperless'] === 'true',
          multicar: row['multicar'] === '1' || row['multicar'] === 'true',
          safeDriver: row['safe_driver'] === '1' || row['safe_driver'] === 'true',
          alarm: row['alarm'] === '1' || row['alarm'] === 'true',
        },
        retainedLastTerm: row['retained_last_term_flag'] === '1' || row['retained_last_term_flag'] === 'true',
        churnRiskScore: parseFloat(row['churn_risk_score_0_1']) || 0,
        claimsOpenCount: parseInt(row['claims_open_count']) || 0,
        claimsClosed12m: parseInt(row['claims_closed_12m']) || 0,
        dataConfidence: row['data_confidence'] || null,
        lastReviewed: row['last_reviewed_date'] ? new Date(row['last_reviewed_date']) : null,
      };
    }

    function parseEventRow(row) {
      return {
        householdId: row['household_id'] || null,
        eventType: row['event_type'],
        minutesSpent: parseFloat(row['minutes_spent']) || 0,
        channel: row['channel'] || null,
        remarketQuoteCount: row['remarket_quote_count_optional'] ? parseInt(row['remarket_quote_count_optional']) : 0,
        wonQuote: row['won_quote_optional'] === '1' || row['won_quote_optional'] === 'true',
        claimCategory: row['claim_cat_optional'] || null,
        lossPaid: parseFloat(row['loss_paid_optional']) || 0,
      };
    }

    function mapHouseholdsCSV(csvText) {
      const raw = parseCSV(csvText);
      return raw.map(parseHouseholdRow);
    }

    function mapEventsCSV(csvText) {
      const raw = parseCSV(csvText);
      return raw.map(parseEventRow);
    }

    /***** Metric Computation *****/
    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function computeBenchScore({ br, rl, sti, tenure, experienceScore, retentionStrength }) {
      // Example normalization + weights
      const wBR = clamp(br, 0, 1);
      const wRL = clamp(1 - rl / 100, 0, 1);
      const wSTI = clamp(1 - sti / 100, 0, 1);
      const wTEN = clamp(tenure / 10, 0, 1);
      const wEXP = clamp(experienceScore, 0, 1);
      const wRET = clamp(retentionStrength, 0, 1);

      const score = (
        wBR * 0.20 +
        wRL * 0.15 +
        wSTI * 0.15 +
        wTEN * 0.15 +
        wEXP * 0.20 +
        wRET * 0.15
      ) * 100;

      return Math.round(score);
    }

    function computeCoverageDepth(households) {
      if (!households.length) return 0;
      const count = households.filter(hh =>
        hh.linesCount >= 2 || hh.bundled || hh.umbrella
      ).length;
      return count / households.length;
    }

    function computeRemarketingLoad(households, events) {
      const total = households.length;
      if (total === 0) return 0;
      const remarketCount = events.filter(e => e.eventType === 'remarket').length;
      return (remarketCount / total) * 100;
    }

    function computeServiceTouchIndex(events, households) {
      const total = households.length;
      if (total === 0) return 0;
      const serviceEvents = events.filter(e => e.eventType === 'service_touch');
      const totalMin = serviceEvents.reduce((s, e) => s + e.minutesSpent, 0);
      return totalMin / total;
    }

    function computeTimeBackNumber(households, events) {
      const total = households.length;
      if (!total) return 0;
      // Here we use your assumption / logic for delta
      const baselineUnbundled = 120; // minutes
      const baselineBundled = 80;
      const delta = baselineUnbundled - baselineBundled;
      const remarketCount = events.filter(e => e.eventType === 'remarket').length;
      const totalDeltaMin = delta * remarketCount;
      const hoursPerYear = totalDeltaMin / 60;
      const hoursPerMonth = hoursPerYear / 12;
      return hoursPerMonth;
    }

    function computeTenureMomentum(households, prevHouseholds) {
      if (!households.length || !prevHouseholds || !prevHouseholds.length) return 0;
      const avgCurr = households.reduce((s, h) => s + h.tenureYears, 0) / households.length;
      const avgPrev = prevHouseholds.reduce((s, h) => s + h.tenureYears, 0) / prevHouseholds.length;
      return avgCurr - avgPrev;
    }

    /***** Badge Logic / Confidence Determination *****/
    function badgeForField(hhList, fieldName) {
      // If any household has dataConfidence = “high” or lastReviewed, mark measured
      if (hhList.some(hh => hh.dataConfidence && hh.lastReviewed)) {
        return 'measured';
      }
      // If field is present (non-zero) in many hh, mark “estimated”
      if (hhList.some(hh => {
        switch (fieldName) {
          case 'service_touches': return hh.serviceTouches12m > 0;
          case 'remarkets': return hh.remarkets12m > 0;
          case 'bundled': return hh.bundled;
        }
        return false;
      })) {
        return 'estimated';
      }
      return 'assumed';
    }

    /***** UI Rendering *****/
    function updateDial(idPrefix, val, badgeText) {
      const valElem = document.getElementById(\`\${idPrefix}-value\`);
      const badgeElem = document.getElementById(\`\${idPrefix}-badge\`);
      if (valElem) {
        valElem.textContent = (typeof val === 'number') ? val.toFixed(2) : val;
      }
      if (badgeElem) {
        badgeElem.textContent = badgeText || '';
      }
    }

    function renderAllDials(metrics, households) {
      updateDial('benchscore', metrics.benchscore, metrics.benchscoreBadge);
      updateDial('timeback', metrics.timeBack, metrics.timebackBadge);
      updateDial('remarketload', metrics.remarketingLoad, metrics.remarketloadBadge);
      updateDial('sti', metrics.serviceTouchIndex, metrics.stiBadge);
      updateDial('depth', metrics.coverageDepth, metrics.depthBadge);
      updateDial('tenure', metrics.tenureMomentum, metrics.tenureBadge);
    }

    /***** Main App Logic *****/
    let households = [];
    let events = [];
    let prevHouseholds = null;

    function computeAllMetrics() {
      const depth = computeCoverageDepth(households);
      const rl = computeRemarketingLoad(households, events);
      const sti = computeServiceTouchIndex(events, households);
      const tb = computeTimeBackNumber(households, events);

      const br = households.length
        ? households.filter(hh => hh.bundled).length / households.length
        : 0;

      const retentionStrength = households.length
        ? households.filter(hh => hh.retainedLastTerm).length / households.length
        : 0;

      const experienceScore = households.length
        ? households.reduce((sum, hh) => {
            const totalClaims = hh.claimsOpenCount + hh.claimsClosed12m;
            const ratio = totalClaims > 0
              ? (hh.claimsClosed12m / totalClaims)
              : 1;
            return sum + ratio;
          }, 0) / households.length
        : 1;

      const avgTenure = households.length
        ? households.reduce((s, hh) => s + hh.tenureYears, 0) / households.length
        : 0;

      const bench = computeBenchScore({
        br,
        rl,
        sti,
        tenure: avgTenure,
        experienceScore,
        retentionStrength
      });

      const tenureMom = computeTenureMomentum(households, prevHouseholds);

      // Badge logic
      const benchBadge = badgeForField(households, 'bundled');
      const tbBadge = badgeForField(households, 'remarkets');
      const rlBadge = badgeForField(households, 'remarkets');
      const stiBadge = badgeForField(households, 'service_touches');
      const depthBadge = badgeForField(households, 'bundled');
      const tenureBadge = tenureMom >= 0 ? 'growing' : 'declining';

      return {
        benchscore: bench,
        timeBack: tb,
        remarketingLoad: rl,
        serviceTouchIndex: sti,
        coverageDepth: depth,
        tenureMomentum: tenureMom,
        benchscoreBadge: benchBadge,
        timebackBadge: tbBadge,
        remarketloadBadge: rlBadge,
        stiBadge: stiBadge,
        depthBadge: depthBadge,
        tenureBadge: tenureBadge
      };
    }

    function handleHouseholdCSV(file) {
      const reader = new FileReader();
      reader.onload = e => {
        prevHouseholds = households.slice();
        const text = e.target.result;
        households = mapHouseholdsCSV(text);
        updateSnapshot();
      };
      reader.readAsText(file);
    }

    function handleEventCSV(file) {
      const reader = new FileReader();
      reader.onload = e => {
        const text = e.target.result;
        events = mapEventsCSV(text);
        updateSnapshot();
      };
      reader.readAsText(file);
    }

    function updateSnapshot() {
      if (!households.length) {
        document.getElementById('upload-error').textContent = 'Please upload a valid household CSV.';
        return;
      }
      document.getElementById('upload-error').textContent = '';
      const metrics = computeAllMetrics();
      renderAllDials(metrics, households);
    }

    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('theme-toggle').addEventListener('click', () => {
        const body = document.body;
        const current = body.getAttribute('data-theme');
        body.setAttribute('data-theme', current === 'dark' ? 'light' : 'dark');
      });
      document.getElementById('household-csv-input').addEventListener('change', ev => {
        const file = ev.target.files[0];
        if (file) handleHouseholdCSV(file);
      });
      document.getElementById('event-csv-input').addEventListener('change', ev => {
        const file = ev.target.files[0];
        if (file) handleEventCSV(file);
      });
    });
  </script>
</body>
</html>
